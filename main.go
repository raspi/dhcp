package main

import (
	"./option"
	"./option/defaults"
	"./option/identifier"
	"./option/ipv4"
	"./option/meta"
	"./option/msgtype"
	"./option/opcodes"
	"./option/seconds"
	"./option/str"
	"bytes"
	"log"
)

func main() {

	rawpacket := []byte{
		0x01, 0x01, 0x06, 0x00, 0x00, 0x00, 0x3d, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x82, 0x01,
		0xfc, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x82, 0x53, 0x63,
		0x35, 0x01, 0x03, 0x3d, 0x07, 0x01, 0x00, 0x0b, 0x82, 0x01, 0xfc, 0x42, 0x32, 0x04, 0xc0, 0xa8,
		0x00, 0x0a, 0x36, 0x04, 0xc0, 0xa8, 0x00, 0x01, 0x37, 0x04, 0x01, 0x03, 0x06, 0x2a, 0xff, 0x00,
	}

	hdr, opts, err := readPacket(bytes.NewReader(rawpacket))

	if err != nil {
		log.Printf(`%#v`, err)
		panic(err)
	}

	log.Printf(`%+v`, hdr)

	typeMap := defaults.GetDefaults()

	options, err := option.RawToTypes(opts, typeMap)

	if err != nil {
		panic(err)
	}

	for _, opt := range options {
		switch o := opt.V.(type) {
		default:
			log.Printf(`??? def:%#v`, opt)

		case option.OptUnknown:
			log.Printf(`type:%v val:%#v`, opt.Type, o.Value)

		case meta.PadOption: // Pad
			log.Printf(`%v`, o)

		case meta.EndOption: // End
			log.Printf(`%v`, o)

		case ipv4.OptIPv4Address:
			log.Printf(`ipv4:%v`, o)

		case ipv4.OptIPv4Addresses:
			log.Printf(`ipv4s:%v`, o)

		case ipv4.OptNetmask:
			log.Printf(`%v`, o)

		case msgtype.Option:
			log.Printf(`type:%v (%v)`, o, o.Type)

		case seconds.Option:
			log.Printf(`time:%v`, o)

		case identifier.Option:
			log.Printf(`id:%v`, o)

		case opcodes.Option:
			log.Printf(`ops:%v`, o)

		case str.Option:
			log.Printf(`%v`, o)

		}

	}

}
